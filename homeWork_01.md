#### Подробно прочитать про метод запроса OPTIONS - и кратко его описать, когда вызывается, где используется, что передает и принимает.####

OPTIONS является одним из стандартных HTTP методов, определенных в спецификации HTTP/1.1. Данный метод используется для описания параметров соединения с целевым ресурсом, метод позволяет узнать, какие HTTP методы поддерживает сервер. Данный метод является безопасным,  идемпотентным и не кэшируемым. 

При запросе данный метод принимает URL конкретного ресурса, или можно указать * . Когда используется * , это означает, что клиент запрашивает информацию о возможностях сервера в целом, а не конкретного ресурса.

**Когда вызывается:** 

Данный метод вызывается перед выполнением других запросов (PUT, GET, POST),  чтобы проверить поддерживает ли сервер необходимый HTTP-метод для определенного ресурса. 

Метод OPTIONS вызывается при реализации CORS (Cross-Origin Resource Sharing) запросов. Браузеры автоматически используют данный метод для отправки предварительного запроса (preflight request), для проверки разрешений на выполнение основного (например, **POST** или **PUT**) запроса на другой домен. Если сервер поддерживает запрашиваемый метод и необходимые заголовки, то браузер выполнит основной запрос.

**Где используется:** 

Данный метод удобно использовать при отладке и тестировании API для получения информации о доступных методах.

В рамках CORS для проверки разрешений на кросс-доменные запросы, что особенно актуально для веб-приложений, взаимодействующих с API на сторонних серверах.

Пример запроса:

`fetch('http://example.org', {method: 'OPTIONS'}).then(res => console.log(res.headers));`

Пример ответа: 

`HeadersList {`
  `cookies: null,`
  `[Symbol(headers map)]: Map(7) {`
    `'allow' => { name: 'Allow', value: 'OPTIONS, GET, HEAD, POST' },`
    `'cache-control' => { name: 'Cache-Control', value: 'max-age=604800' },`
    `'content-type' => { name: 'Content-Type', value: 'text/html; charset=UTF-8' },`
    `'date' => { name: 'Date', value: 'Sun, 27 Oct 2024 00:13:14 GMT' },`
    `'expires' => { name: 'Expires', value: 'Sun, 03 Nov 2024 00:13:14 GMT' },`
    `'server' => { name: 'Server', value: 'EOS (vny/044F)' },`
    `'content-length' => { name: 'Content-Length', value: '0' }`
  `},`
  `[Symbol(headers map sorted)]: null`
`}`

Основные заголовки которые возвращает сервер:

- `Allow`: список поддерживаемых HTTP-методов
- `Access-Control-Allow-Methods`: разрешенные методы для CORS
- `Access-Control-Allow-Headers`: разрешенные заголовки
- `Access-Control-Max-Age`: время кэширования preflight-запроса

#### Прочитать и описать ключевые особенности "HTTP" Версии 3.0

HTTP/3 - это последняя основная версия HTTP. Веб-браузеры и серверы могут использовать её для значительного улучшения пользовательского опыта, включая производительность, надёжность и безопасность. Согласование версий HTTP происходит незаметно, не требуя изменений в коде веб-сайта.

Ключевой особенностью данной версии является использование нового транспортного протокола QUIC (Quick UDP Internet Connections).  Данный протокол основан на UDP (User Datagram Protocol) вместо TCP. Это позволяет уменьшить задержку и улучшить производительность, особенно в условиях плохого интернет-соединения.

##### **Улучшения HTTP/3:**

- **QUIC** — это протокол транспортного уровня, разработанный для замены TCP. HTTP/3 использует QUIC вместо TCP, что позволяет сократить задержки, улучшить производительность при передаче данных и избежать некоторых проблем, присущих TCP.
- **QUIC** работает поверх UDP, что позволяет избежать трехэтапного установления соединения TCP и быстрее начинать передачу данных.

##### **Мультиплексирование и отсутствие блокировки по очереди**

- В HTTP/2, несмотря на возможность одновременной передачи данных по нескольким потокам, все потоки идут через одно TCP-соединение. При потере одного пакета, TCP вынужден ждать его восстановления, что блокирует все остальные потоки (это называется **head-of-line blocking**).
- В HTTP/3 такой проблемы нет. Пакеты передаются независимо, и потеря одного пакета не влияет на остальные потоки, что обеспечивает более стабильную и быструю передачу данных.

#### **Ускоренная установка соединения**

- Благодаря QUIC, HTTP/3 использует **zero-round-trip time (0-RTT)** при повторном соединении. Это означает, что для повторного подключения к серверу клиент может начать передачу данных сразу, без ожидания подтверждения от сервера, что значительно ускоряет загрузку.
##### **Улучшенная безопасность и встроенное шифрование**

- Протокол QUIC имеет встроенную поддержку TLS 1.3, что обеспечивает высокий уровень безопасности. Все данные в HTTP/3 зашифрованы по умолчанию, в отличие от HTTP/2, где шифрование не обязательно.
- Использование TLS 1.3 на уровне транспортного протокола уменьшает количество шагов для установки защищенного соединения, что делает соединение быстрее и безопаснее.

##### **Устойчивость к нестабильному соединению**

- HTTP/3 сохраняет текущее соединение при смене IP-адреса, что особенно полезно для мобильных пользователей, которые могут переключаться между сотовыми сетями и Wi-Fi. QUIC сохраняет сессию, связывая её с уникальным идентификатором, а не с IP-адресом.
- Это делает HTTP/3 более устойчивым к перебоям в соединении и способствует более плавной передаче данных в условиях нестабильной сети.

##### **Улучшенная производительность при стриминге и загрузке веб-страниц**

- Возможность одновременной передачи данных и быстрая установка соединений позволяют HTTP/3 быть более эффективным для современных веб-сервисов, включая потоковое видео, аудио, интерактивные приложения и игры.
- HTTP/3 ускоряет загрузку веб-страниц и уменьшает задержки для пользователей, что особенно важно для приложений с высоким требованием к скорости передачи данных.


#### Прочитать про способы отмены запроса, включая объект "AbortController"

**AbortController** — это класс, представленный в JavaScript, который позволяет управлять асинхронными операциями, такими как `Fetch запросы, Promise, fs, setTimeout и setInterval`. 
Данный класс предоставляет возможность контролировать выполнение асинхронных операций, путем предотвращения ненужных операций. 

Для создания экземпляра AbortController используется конструктор класса: 

```
const controller = new AbortController();
```

```
После создания экземпляра AbortController, можно получить экземпляр AbortSignal, используя свойство signal:
```

```
const signal = controller.signal;
```

Пример: 

```
const controller = new AbortController();

const signal = controller.signal;

setTimeout(() => {
controller.abort();
}, 3000);


fetch('url', { signal })
.then(res => res.json())
.then(data => console.log(data))
.catch(err => {
if (err.name === 'AbortError'){
console.log('Request aborted')
} else {
console.error('Request failed', error)
}
});
```

В этом примере через 3 секунды после начала запроса к API, будет вызван метод abort(), что приведет к отмене запроса. Если запрос не будет завершен в течение 3 секунд, обработчик ошибок перехватит событие отмены и выведет соответствующее сообщение в консоль. Если же запрос успеет завершиться раньше, результат будет обработан и выведен в консоль без отмены.

При использовании AbortController важно правильно обрабатывать возможные ошибки. Когда операция отменяется, она обычно вызывает ошибку `AbortError`. Это позволяет определить, была ли операция завершена успешно или отменена или завершилась по другой причине.


#### Написать по 2 примера создания примитивных значений (если есть несколько способов - использовать) (string, number, boolean, null, undefined, symbol, bigInt)

**String**

```
const name = 'Max'; 
let age = "23";
// Создание через конструктор
let country = String('Russia'); // создает примитвную строку
let strWithNew = new String('строка'); // создает объект String
const stringWithVariables = `user - ${name}, ${age}, ${country}` // используются шаблонные строки
```

Мы просто создали одну строку и «вставили» в неё в нужные места константы с помощью знака доллара и фигурных скобок `${ }`.  Работает только с обратными кавычками.

**Number**

```
const num1 = 5;
let num2 = 6;
const num3 = new Number(7); // создает объект Number
const num4 = Number(8);  // создает примитивное число
let num5 = +'9' // унарный плюс преобразует строку в число
let num8 = 1e6; // экспоненциальная запись
let hexNum = 0xFF; // шестнадцитиричная запись
let binaryNum = 0b1010; // бинарная запись
let octalNum = 0o744; // восьмиричная запись
```

**Boolean** 

```
let isTrue = true;
let isFalse = false;

let isTrueWithConstructor = Boolean(1);

let anotherTruthy = 4 < 5; // с использованием выражения

let anotherTruthy2 = !!"строка" // используется двойное отрицание для 

// использование логических операций
let and = true && true; // true 
let or = false || true; // true 
let not = !false;

// использование тернарного оператора 
let isAdult = age >= 18 ? true : false;

```

**NULL**

```
let data = null;
let user = null;

// Возврат значения из функции 

function getValue(){
return null;
}
```

**undefined**

```
let value = undefined; // явное присваивание
let variable; // Объявление переменной без инициализации
```

Также стоит отметить, если функция не содержит оператора return, по умолчанию возвращает undefined.

**symbol** 

```
let sym1 = Symbol();

let sym2 = Symbol("description"); // символ с описанием
```


**bigInt**

```
let bigInt1 = 1234567890123456789012345678901234567890n;

let bigInt2 = BigInt("9007199254740991");
```


#### Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем **ReferenceError**?

Когда мы пытаемся обратиться к переменным, объявленным через `let` или `const` до их фактического объявления, мы получаем ошибку `ReferenceError` из-за концепции, известной как **"временная мёртвая зона"** (Temporal Dead Zone, TDZ).

Свойства переменных, созданных с помощью `let` и `const`, гарантируют, что доступ к переменной возможен **только после её объявления**.

Во время выполнения кода интерпретатор JavaScript создает **область видимости** для каждой функции или блока кода и подготавливает все переменные и функции к использованию. Переменные, объявленные с помощью `let` и `const`, определяются, но в отличие от `var`, они не инициализируются значением `undefined` и не доступны для использования до фактического момента объявления. Эта область между началом исполнения блока и самой строкой с объявлением переменной и есть временная мёртвая зона.

#### Решить 

```
const res = "B" + "a" + (1 - "hello"); 
console.log(res); // BaNan
```
 - В данном примере 'B' и 'a' - строки, результатом их сложения будет строка 'Ba'.
 - Результатом (1-'hello') будет NaN так как строка 'hello' не может быть приведена к числу.
 - 'Ba' + Nan, в результате конкатенации будет строка 'BaNan'

```
const res2 = (true && 3) + "d"; 
console.log(res2); // 3d
```

- `(true && 3)` — оператор `&&` возвращает значение второго операнда, если первый операнд истинный, иначе возвращает первый. Здесь `true && 3` дает `3`.
- `3 + "d"` — это сложение числа и строки, которое приводит к конкатенации, и результат будет строкой `"3d"`.

```
const res3 = Boolean(true && 3) + "d"; 
console.log(res3); // trued
```

- `(true && 3)` — как и раньше, результат `3`.
- `Boolean(3)` — `Boolean` возвращает `true` для всех значений, кроме `0`, `null`, `undefined`, `NaN` и `""`. Поскольку `3` является истинным значением, `Boolean(3)` даст `true`.
- `true + "d"` — `true` приводится к строке `"true"`, и результат — строка `"trued"`.