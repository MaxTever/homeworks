# homeWork_06
## Почитать про принципы программирования KISS, DRY, YAGNI + почитать про "Антипаттерны" Чистого кода

#### KISS

KISS - это принцип проектирования и программирования, при котором простота системы декларируется в качестве основной цели или ценности. Есть два варианта расшифровки аббревиатуры: «keep it simple, stupid» и более корректный «keep it short and simple»

**В проектировании следование принципу KISS выражается в том, что:**

- не имеет смысла реализовывать дополнительные функции, которые не будут использоваться вовсе или их использование крайне маловероятно
- не стоит перегружать интерфейс теми опциями, которые не будут нужны большинству пользователей
- бессмысленно делать реализацию сложной бизнес-логики, которая учитывает абсолютно все возможные варианты поведения системы, пользователя и окружающей среды

**В программировании следование принципу KISS можно описать так:**
- не имеет смысла беспредельно увеличивать уровень абстракции, надо уметь вовремя остановиться
- бессмысленно закладывать в проект избыточные функции «про запас», которые может быть когда-нибудь кому-либо понадобятся
- не стоит подключать огромную библиотеку, если вам от неё нужна лишь пара функций
- декомпозиция чего-то сложного на простые составляющие — это архитектурно верный подход
- абсолютная математическая точность или предельная детализация нужны не всегда

#### DRY

Принцип программирования DRY — don’t repeat yourself / не повторяйте себя.

Следование принципу программирования «DRY» позволяет добиться высокой сопровождаемости проекта, простоты внесения изменений и качественного тестирования.

Если код не дублируется, то для изменения логики достаточно внесения исправлений всего в одном месте. Также проще тестировать одну (пусть и более сложную) функцию, а не набор из десятков однотипных.

Следование принципу DRY всегда приводит к декомпозиции сложных алгоритмов на простые функции. Декомпозиция же сложных операций на более простые значительно упрощает понимание программного кода. Также становится возможным повторное использование функций, вынесенных из сложных алгоритмов, что позволяет сократить время разработки и тестирования новой функциональности.

Следование принципу DRY приводит к модульности приложения и к чёткому разделению ответственности за бизнес‑логику между программными классами, то есть к сопровождаемой архитектуре. Хотя в больших проектах чаще не следование DRY приводит к модульности, а скорее модульность обеспечивает принципиальную возможность соблюдения этого принципа.

В рамках одного программного класса или модуля следовать DRY и не повторяться обычно достаточно просто. Также не требует титанических усилий делать это в рамках небольших проектов, где все разработчики «владеют» всем кодом системы. А вот в больших проектах ситуация с DRY несколько сложнее — повторы чаще всего появляются из‑за отсутствия у разработчиков целостной картины или несогласованности действий в рамках команды.

Следовать принципу «don’t repeat yourself» в рамках больших проектов не так просто, как это может показаться на первый взгляд. От разработчиков требуется тщательное планирование архитектуры, а от архитектора или тимлида требуется наличие видения системы в целом и чёткая постановка задач разработчикам.

Идея вращается вокруг единого источника правды (single source of truth — SSOT).

Использование SSOT позволит создать более прочную и понятную кодовую базу.  
  
Дублирование кода приводит к  поддержке одной и той же логику и тестированию кода сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.

#### YAGNI

**«You aren't gonna need it»** — процесс и принцип проектирования, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности, — то есть отказ добавления функциональности, в которой нет непосредственной надобности.

Основная проблема, которую решает принцип YAGNI — это устранение тяги программистов к излишней абстракции, к экспериментам «из интереса» и к реализации функционала, который сейчас не нужен, но, по мнению разработчика, может вскоре понадобиться или просто будет полезен, хотя в реальности такого часто не происходит.

Принципы YAGNI и [KISS](https://web-creator.ru/articles/kiss) очень похожи, если KISS нацелен на упрощение и полезен в плане работы с теми требованиями, которые имеют место быть, то YAGNI более категоричен и применяется для ограждения проектов по разработке ПО от «размывания» их рамок.


## Антипаттерны чистого кода

**Антипаттерн** - это шаблон проектирования, который кажется полезным, но на практике приводит к проблемам. В контексте чистого кода антипаттерны - это ошибки в проектировании, структуре или стиле кода, которые делают его сложным для понимания, поддержки и расширения.

**Основные антипаттерны чистого кода:**

**1. Large Class/God Object:**

- **Описание:** Класс или метод, который делает слишком много, содержит слишком много кода и отвечает за слишком много функциональности.
- **Проблемы:**
    - Трудно понять и поддерживать.
    - Сложно тестировать.
    - Нарушает принцип единственной ответственности.
- **Решение:**
    - Разделите большой класс на несколько классов с четко определенными обязанностями.
    - Разбейте большой метод на несколько более мелких методов с четко определенными задачами.
    
**2. Магические числа и строки (Magic Numbers/Strings):**

- **Описание:** Использование "магических" чисел или строк в коде без объяснения их значения.
    
- **Проблемы:**
    - Сложно понять, что означают эти значения.
    - При изменении значения нужно искать все его вхождения в коде.
- **Решение:**
    - Замените магические числа и строки константами с понятными именами.

**3. Copy-Paste Programming:**

- **Описание:** Дублирование кода вместо его вынесения в отдельный метод или класс.
    
- **Проблемы:**
    
    - Трудно поддерживать, так как изменения нужно вносить в нескольких местах.
    - Увеличивает объем кода.
- **Решение:**
    - Вынесите дублирующийся код в отдельный метод или класс.

**4. Слишком умный код (Over-engineering):**

- **Описание:** Написание кода, который слишком сложный для решаемой задачи.
- **Проблемы:**
    - Сложно понять и поддерживать.
    - Замедляет разработку.
- **Решение:**
    - Пишите простой и понятный код.
    - Используйте шаблоны проектирования только когда это действительно необходимо.

**5. Неявные зависимости (Hidden Dependencies):**
- **Описание:** Зависимости между классами или методами неявны и не документированы.
    
- **Проблемы:**
    - Сложно понять, как работает код.
    - Сложно тестировать.
- **Решение:**
    - Явно объявляйте зависимости через конструктор или методы.       
    - Используйте инъекцию зависимостей.        

**6. Неиспользуемый код (Dead Code):**

- **Описание:** Код, который никогда не выполняется или не используется.
    
- **Проблемы:**
    
    - Увеличивает объем кода.
    - Затрудняет понимание.
- **Решение:**
    - Удалите неиспользуемый код.

**7. Неинформативные имена (Non-descriptive Naming):**

- **Описание:** Использование неинформативных имен переменных, методов и классов.
- **Проблемы:**
    - Сложно понять, что делает код.
    - Увеличивает время на разработку и отладку.
- **Решение:**
    - Используйте понятные и описательные имена.
    - Следуйте соглашениям об именовании.

**8. Слишком много уровней абстракции (Too Many Layers of Abstraction):**
- **Описание:** Создание слишком большого количества уровней абстракции.
    
- **Проблемы:**
    - Сложно понять, как работает код.
    - Увеличивает время на разработку и отладку.
- **Решение:**
    - Используйте абстракции только когда это действительно необходимо.
    - Убедитесь, что каждый уровень абстракции имеет четко определенную ответственность.

**9. Неуместная сложность (Inappropriate Complexity):**

- **Описание:** Использование сложных решений для простых задач.
    
- **Проблемы:**
    - Сложно понять и поддерживать.
    - Замедляет разработку.
- **Решение:**
    - Используйте простые и понятные решения.
    - Не усложняйте код без необходимости.

**10. Отсутствие документации (Lack of Documentation):**
- **Описание:** Отсутствие комментариев и документации к коду
- **Проблемы:**
    - Сложно понять, как работает код.
    - Сложно поддерживать.
- **Решение:**
    - Документируйте важные части кода.
    - Используйте комментарии для объяснения сложных или неочевидных моментов.

## Прочитать про способы хранения LocalStorage, SessionStorage и Cookie

При разработке современных веб-сайтов достаточно часто необходимо сохранять данные на стороне клиента. Для таких целей в браузере существует несколько разных способов, которые появились в разное время и отличаются друг от друга.

Web Storage – это интерфейс взаимодействия с хранилищем. Есть две реализации этого API: Local Storage и Session Storage. Оба способа имеют идентичный API и ограничения, а основным различием является время хранения данных.

#### Local storage

Local Storage - это объект, хранящийся в `window`, который позволяет долговременно сохранять данные в браузере. Работает как хранилище данных в формате ключ-значение — при сохранении данных мы указываем имя поля, в которое должны быть сохранены данные, и затем используем это имя для их получения.

Значения хранятся в виде строк. При попытке сохранения других типов данных, они будут приведены к строке. Например, если записать число, то при чтении нам вернётся число, записанное в строку.

Не имеет ограничений по времени хранения, может быть очищен пользователем вручную или браузером при переполнении автоматически (браузеры на основе движка WebKit, например Safari, очищают `localStorage`, если к нему не обращались в течение 7 дней).

Максимальный объем данных ограничен размером 5MB.

**Пример записи данных**

Для этого используется setItem('key', 'value')
```
window.localStorage.setItem('name', 'Вася')
```


**Пример чтения данных**

Для этого используется getItem('key')

```
const name = window.localStorage.getItem('name')
console.log(name) // Вася
```

**ВАЖНО!** **Повторная запись по тому же ключу приведет к перезаписи значения**

Если необходимо сохранить данные в браузере на долгое время и объем этих данных достаточно большой, то `localStorage` — может подойти для этих целей. Данные будут храниться бессрочно и могут быть стёрты только в двух случаях: при превышении лимита по размеру данных или очистке хранилища пользователем или программно.

**Удаление данных**

Для удаления данных из LocalStorage используется removeItem('key'). Особенностью является что, успешное выполнение даже при отсутствии ключа.

**Очистка хранилища**

За это отвечает метод `clear`, который полностью очищает хранилище.

```
window.localStorage.clear()
```

**Количество полей в хранилище**

Для проверки количества полей в хранилище можно использовать свойство length.

```
console.log(window.localStorage.length)
```

**Получение ключа по индексу**

Метод `key()` получает ключ по индексу. Значения в хранилище хранятся в порядке их добавления, поэтому значение, добавленное первым, будет храниться в позиции `0` и так далее.

```
window.localStorage.setItem('name', 'Дока Дог') console.log(window.localStorage.key(0))
```

Из-за этого можно использовать перебор всех значений по индексу

```
const localStorageSize = window.localStorage.length
for (let i = 0; i < localStorageSize; i++) {
  console.log(
    window.localStorage.getItem(localStorage.key(i))
  )
}
```


**События**

При установке значения в хранилище срабатывает глобальное событие `storage`, с помощью которого можно отслеживать изменения в хранилище.

Событие происходит только на других открытых страницах текущего сайта.

Событие содержит свойства:
- `key` — ключ, который был изменён (при вызове метода `clear()` ключ будет `null`);
- `oldValue` — старое значение, записанное в поле;
- `newValue` — новое значение, записанное в поле;
- `url` — адрес страницы, на которой вызвано изменение.

```
window.addEventListener('storage', function (evt) {
  console.log(evt)
})
```


LocalStorage можно использовать для синхронизации нескольких открытых вкладок в браузере.

```
function changePageFontSize(size) {
  document.style.fontSize = `${size}px`
}

window.addEventListener('storage', function (evt) {
  if (evt.key === 'pageFontSize') {
    changePageFontSize(evt.newValue)
  }
})

```

Иногда нам нужно сохранить не просто текст, а целую структуру данных. В этом нам поможет `JSON.stringify()`.

```
const user = { name: 'Дока Дог', avatarUrl: 'mascot-doka.svg' } localStorage.setItem('user', JSON.stringify(user))
```

#### Session Storage

Это объект, хранящийся в `window`, который позволяет сохранять данные в браузере на время сессии. Этот тип хранилища очень похож на `localStorage` и работает как хранилище данных в формате ключ-значение. При сохранении данных мы указываем имя поля, в которое должны быть сохранены данные, и затем используем это имя для их получения.

- Сессия страницы создаётся при открытии новой вкладки браузера. Сессия остаётся активной до тех пор, пока открыта вкладка, а состояние сессии сохраняется между перезагрузками. Открытие новой вкладки с таким же адресом приведёт к созданию новой сессии.
- Значения хранятся в виде строк. При попытке сохранения других типов данных, они будут приведены к строке. Например, если записать число, то при чтении нам вернётся число, записанное в строку.
- Максимальный объем данных ограничен размером 5MB.

**Запись данных**

```
window.sessionStorage.setItem('name', 'Ivan')
```

**Чтение данных**

```
const name = window.sessionStorage.getItem('name')
console.log(name) // Ivan
```

**Повторная запись по тому же ключу приведёт к замене данных!!!**

**Очистка хранилища**

Данное действие производится с помощью `clear()`

```
window.sessionStorage.clear()
```

**Количество полей в хранилище**

```
window.sessionStorage.length
```

**Получение ключа по индексу**

Метод `key()` получает ключ по индексу. Значения в хранилище хранятся в порядке их добавления, поэтому значение, добавленное первым, будет храниться в позиции `0` и так далее.

```
console.log(window.sessionStorage.key(0))
```

#### Cookie

При разработке часть информации (например, токен авторизации или данные пользователя) нужно хранить и читать как в браузере, так и на сервере. Для этого используют **Cookie** (произносится «куки»).

Куки передаются в виде HTTP-заголовка, это накладывает на них ограничения. Например, максимальный размер куки в 4096 байт или отсутствие в содержимом пробелов или запятых. Чтобы обезопасить содержимое, можно закодировать его с помощью функции `encodeURIComponent()`.

Все куки хранятся в свойстве `document.cookie`. Это свойство представляет собой строку в формате `имя=значение`, где пары имён и значений разделяются знаком `;` . При этом взаимодействие с полем весьма необычное — если присвоить `document.cookie` новое значение, то оно не заменит полностью старую строку, а добавит или изменит значение по ключу.

**Запись**

Запись в cookie работает с помощью присвоения значения новой куки в поле `document.cookie`. За один раз можно записать лишь одно значение.

Вот так можно добавить значение 1 по ключу _counter_:

```
document.cookie = 'counter=1'
console.log(document.cookie)
// 'counter=1'
```

При присвоении свойству куки с другим именем, получим два записанных значения:

```
document.cookie = 'sidebar=false'
console.log(document.cookie)
// 'counter=1; sidebar=false;'
```

При повторной записи в то же поле другого значения оно будет перезаписано.

При установке кук можно указывать не только её название и значение, но и другие параметры. Все они являются необязательными и разделяются точкой с запятой `;`.

- `path` — определяет путь, по которому будет доступна кука. Он должен быть абсолютным, то есть начинаться с `/`. Если параметр не передан, то кука будет доступна на всех страницах сайта.
- `domain` — определяет домен, для которого указана кука. Если не указано, то будет использоваться текущий домен.
- `max-age` и `expires` — определяет время жизни куки.`max-age` указывает, через сколько секунд, а `expires` указывает точное время, когда кука станет недействительна. Время для `expires` можно отформатировать с помощью встроенного метода даты `Date.toUTCString()`
- `secure` — указывает, что данная кука может быть передана только при запросах по защищённому протоколу HTTPS.
- `samesite` — определяет, может ли данная кука быть отправлена при кроссдоменном запросе. Значение параметра `strict` будет предотвращать отправку на другие домены, а `lax` разрешит отправлять куки с GET-запросами.

Есть пара ограничений при специфичных названиях кук. Если название куки начинается с `__Secure-`, то обязательно должен быть передан параметр `secure`. При этом мы должны находиться на странице, которая была получена по HTTPS-протоколу. Если название куки начинается с `__Host-`, то обязательно должны быть переданы параметры `path=/` и `secure` (страница также должна быть открыта по HTTPS-протоколу), а атрибут `domain` должен отсутствовать для снижения кроссдоменных уязвимостей.

Запись куки с разрешением передавать её только по HTTPS и только для текущего домена, со временем жизни в 1 час будет выглядеть так:

```
document.cookie = 'sidebar=true;secure;samesite=strict;max-age=3600'
```

![[Pasted image 20241115231748.png]]
  
Для установки куки, которая будет доступна на текущем домене и всех его поддоменах, используйте название текущего домена и поставьте точку в начале — `.${window.location.hostname}`.

При записи нескольких кук, для получения значения конкретной куки, нужно будет прочитать строки и разобрать её по значениям.

```
function getCookie() {
  return document.cookie.split('; ').reduce((acc, item) => {
    const [name, value] = item.split('=')
    acc[name] = value
    return acc
  }, {})
}

const cookie = getCookie()

console.log(cookie.counter)
console.log(cookie.sidebar)
```

#### Удаление

Для кук не предусмотрено специального метода удаления, поэтому для этого используется трюк с установкой кук с параметром `expires` который указывает на дату в прошлом. Браузер сразу же считает такую куку устаревшей и удаляет её:

```
document.cookie = `sidebar=;expires=${new Date(0)}`
```

Есть куки, которые нельзя прочитать или записать из JavaScript. Если сервер устанавливает куки с параметром `HttpOnly` (доступен только для установки сервером), то такие куки будут недоступны в `document.cookie`. Как правило, такие куки используются для хранения чувствительной информации, как, например, токены для авторизации. Проверка авторизации происходит с помощью запроса с текущим авторизованным пользователем и считается при успешном ответе сервера.

Для упрощения работы с куками можно использовать библиотеку js-cookie

### HTML / CSS - Базовая структура html документа, БЭМ методология

Каждый HTML-документ начинается с декларации типа документа или «доктайпа». Тип документа необходим, чтобы браузер мог определить версию HTML и правильно отобразить страницу.

```
<!DOCTYPE html>
```

Простейшая HTML-страница состоит как минимум из трёх тегов: **`<html>`, `<head>` и `<body>`.** Тег `<head>` обычно содержит заголовок, ключевые слова, описание страницы и другие служебные данные. Также внутри него подключаются внешние ресурсы, например, стили. Содержимое этого тега не отображается на странице напрямую. А в теге `<body>` хранится содержание страницы, которое отображается в окне браузера.

Для подключения стилей к странице существует тег `<link>`. Для этого у него есть атрибут `href` в котором задаётся адрес стилевого файла, а значение `stylesheet` атрибута `rel` говорит браузеру, что мы подключаем именно стили, а не что-то другое.

```
<head>
  <link href="адрес_файла_стилей.css" rel="stylesheet">
</head>
```

Ещё один элемент, который располагается в `<head>` — это тег `<title>`. В нём задаётся заголовок страницы, который отображается во вкладках браузера. По заголовку должно быть понятно, о чём эта страница, даже когда она не открыта в браузере, а отображается в результатах поиска или в браузерных закладках.

```
<head>
  <title>Тренажёры — HTML Academy</title>
</head>
```

Ещё один важный тег, располагающийся внутри `<head>` это тег `<meta>`. Он одиночный, то есть не требует парный закрывающий тег в конце. С помощью `<meta>` можно сообщать браузеру, поисковому роботу или другому устройству различную служебную информацию (или метаинформацию) о вашем сайте: кодировку текста, описание контента и так далее. Для этого используются теги `<meta>` с разными атрибутами и их значениями.

Кодировка текста HTML-страницы указывается с помощью атрибута `charset`:

```
<meta charset="название кодировки">
```

Самая распространённая современная кодировка — `utf-8`.

Перечень ключевых слов задаётся тегом `<meta>`, у которого атрибут `name` имеет значение `keywords`. Ключевые слова (самые важные слова из содержания страницы) перечисляются в атрибуте `content` через запятую:

```
<meta name="keywords" content="важные, ключевые, слова">
```

Краткое описание (или аннотация) страницы задаётся похожим образом, только значение атрибута `name` меняется на `description`:

```
<meta name="description" content="краткое описание">
```

Внутри `<body>` находятся те теги, которые отображаются на странице. Например, тег `<main>` выделяет основное содержание страницы, которое не повторяется на других страницах. И обычно на странице используется один `<main>`.

Тег `<header>` содержит вводную часть страницы, которую чаще называют «шапкой», а тег `<footer>` описывает заключительную часть страницы, или «подвал». Существует тег `<section>`, который обозначает крупный смысловой (или «логический») раздел.

Тег `<article>`, обозначает цельный, законченный и самостоятельный фрагмент информации.

Для создания логического раздела с основной навигацией предназначен тег `<nav>` (сокращение от английского «navigation»). Обычно в `<nav>` включают ссылки на другие страницы или навигацию по текущей странице.

Тег `<aside>` включает в себя дополнительное содержание, не связанное напрямую с основным. Такие блоки ещё часто называют «сайдбарами» или боковыми панелями.

Для создания основной структуры текста используют заголовки. В HTML существует целое семейство заголовочных тегов: от `<h1>` до `<h6>`. Тег `<h1>` обозначает самый важный заголовок (заголовок верхнего уровня), а тег `<h6>` обозначает подзаголовок самого нижнего уровня.

```
<h1>Спецификация HTML</h1>
<h2>Раздел 1 Введение</h2>
<h3>Раздел 1.1 Происхождение языка</h3>
```

Основную структуру текста создают с помощью заголовков, а более мелкую выстраивают с помощью параграфов (или абзацев). Для разметки параграфов предназначен тег `<p>`. По умолчанию абзацы начинаются с новой строки и отделяются от остального контента отступами сверху и снизу.

## CSS 

CSS (Cascading Style Sheets) — это код, который  используется для стилизации веб-страницы. Как и HTML, CSS на самом деле не является языком программирования. Это не язык разметки - это _язык таблицы стилей._ Это означает, что он позволяет применять стили выборочно к элементам в документах HTML. 

Существует несколько вариантов подключения CSS к HTML:  

#### Подключение внешних стилей 

Внешняя таблица стилей содержит CSS в отдельном файле с расширением .css. Это наиболее распространенный и полезный метод добавления CSS в документ. В данном подходе отдельный файл CSS подключается к HTML. Для этого используется тег `<link>` в блоке `<head>`.

```
<link rel="stylesheet" href="style.css">
```

#### Внутренние стили 

Внутренняя таблица стилей находится внутри HTML-документа. Чтобы создать внутреннюю таблицу стилей, вы помещаете CSS внутрь элемента `<style>`, содержащегося внутри HTML `<head>`. 

```
<!doctype html>
<html lang="en-GB">
  <head>
    <meta charset="utf-8" />
    <title>My CSS experiment</title>
    <style>
      h1 {
        color: blue;
        background-color: yellow;
        border: 1px solid black;
      }

      p {
        color: red;
      }
    </style>
  </head>
  <body>
    <h1>Hello World!</h1>
    <p>This is my first CSS example</p>
  </body>
</html>


```

В некоторых случаях внутренние таблицы стилей могут быть полезны. Например, возможно, вы работаете с системой управления контентом, где вам запрещено изменять внешние файлы CSS.

Но для сайтов с более чем одной страницей внутренняя таблица стилей становится менее эффективным способом работы. Чтобы применить единообразный стиль CSS к нескольким страницам с помощью внутренних таблиц стилей, вам необходимо иметь внутреннюю таблицу стилей на каждой веб-странице, которая будет использовать этот стиль. Потеря эффективности также распространяется на обслуживание сайта. С CSS во внутренних таблицах стилей существует риск того, что даже одно простое изменение стиля может потребовать редактирования нескольких веб-страниц.

#### Inline подключение стилей 

Встроенные стили — это объявления CSS, которые влияют на один элемент HTML, содержащийся в атрибуте стиля. Реализация встроенного стиля в документе HTML может выглядеть следующим образом:

```
<h1 style="color: blue;background-color: yellow;border: 1px solid black;">
```

Лучше избегать использования Inline стилей, когда это возможно. Одной из причин для этого является неудобство в обслуживании  и поддержке. Так же это приводит к большому количеству дублирования кода. При этом если используется внешнее подключение CSS, могут возникнуть конфликты, так как inline стили обладают большей специфичностью.


Если рассматривать внешнее подключение стилей, то весь CSS состоит из однотипных блоков — CSS-правил. Каждое правило состоит из как минимум одного селектора и одной пары свойство-значение.

Написанное ниже правило _найдёт_ все заголовки второго уровня в HTML и покрасит их в зелёный цвет:

```
h2 {
  color: #32a846;
}
```

При помощи селектора мы _говорим_ браузеру, к какому именно элементу будут применяться свойства.

Есть разные типы селекторов. Подробнее о них можно почитать в отдельных статьях:

- универсальный селектор;
- селекторы по тегу;
- селектор по классу;
- селектор по идентификатору;
- селектор по атрибуту.

Можно написать правило сразу для нескольких селекторов, перечислив их через запятую:

```
.first-selector,
.next-selector {
  color: #6e4aff;
}
```
Селекторы можно разным образом комбинировать между собой. Подробнее в статье про комбинированные селекторы.
Сразу после селектора пишутся фигурные скобки `{ }`. Внутри них будут перечислены свойства и значения.

### БЭМ методология 

БЭМ (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки. Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно использовать существующий код, избегая «Copy-Paste».

Функционально независимый компонент страницы, который может быть повторно использован. В HTML блоки представлены атрибутом `class`.

### Блок

Логически и функционально независимый компонент страницы, аналог компонента в Web Components. Блок инкапсулирует в себе поведение (JavaScript), шаблоны, стили (CSS) и другие технологии реализации. Независимость блоков обеспечивает возможность их повторного использования, а также удобство в разработке и поддержке проекта.

**Возможности блоков:**
- Вложенная структура
- Свободное перемещение
- Повторное использование
### Вложенная структура

Блоки можно вкладывать в любые другие блоки.
Например, блок `head` может содержать логотип (`logo`), форму поиска (`search`) и блок авторизации (`auth`).
### Свободное перемещение

Блоки можно перемещать в пределах одной страницы и разных проектов. Независимость блока позволяет изменять его положение на странице и обеспечивает корректную работу и внешний вид.
Так, например, логотип и форму авторизации можно поменять местами. При этом вносить изменения в CSS или JavaScript-код блоков не нужно.

### Повторное использование

В интерфейсе может одновременно присутствовать несколько экземпляров одного и того же блока.

```
// Пример блока 
<form class='search-form'></form> 
```


### Элемент

Составная часть блока, которая не может использоваться в отрыве от него. Элементы не существуют вне блока. Каждый элемент может принадлежать только одному блоку.
Например, пункт меню вне блока меню не используется, значит является его элементом.
#### Когда создавать элемент, а когда блок.

Если фрагмент  кода может использоваться повторно и не зависит от реализации других компонентов страницы. **То в данном случае лучше создавать блок**

**Элемент стоит создавать когда:** Если фрагмент кода не может использоваться самостоятельно, без родительской сущности. 

Элемент - всегда часть блока, а не другого элемента. Это означает, что в названии элементов **нельзя прописывать иерархию вида** `block__elem1__elem2`

```
// Пример элемента 
<form class='search-form'>
	<input class='search-form__input'> 
	<button class='search-form__button'></button>
</form>

// Пример вложенности 
<div class='block'>
	<div class='block__elem1'>
		<div class='block__elem2'>
			<div class='block__elem3'></div>
		</div>
	</div>
</div>
```

### Модификатор

БЭМ-сущность, определяющая внешний вид, состояние и поведение блока или элемента.

Использование модификаторов опционально, количество — неограничено. Блоку или элементу нельзя одновременно присвоить разные значения модификатора.

По своей сути модификаторы похожи на атрибуты в HTML. Один и тот же блок выглядит по-разному благодаря применению модификатора.

Например, внешний вид блока меню (`menu`) может меняться в зависимости от примененного модификатора.
Модификаторы могут изменяться в процессе работы блока (например, как реакция на DOM-события блока) и по запросу из других блоков.

Например, при клике по кнопке `Sign In` (DOM-событие click), в случае неверно заполненных полей `Login` или `Password`, на скрытый блок сообщений об ошибках устанавливается модификатор (`visible`).

Название модификатора характеризует внешний вид `button_disabled`.

Имя модификатора отделяется от имени блока или элемента одним подчеркиванием.

#### Типы модификатора

1) Булевый тип
	- Используется когда важно наличие или отсутствие модификатора. 
	- Структура полного имени модификатора соответствует схеме `имя-блока_имя-модификатора`, `имя-блока__имя-элемента_имя-модификатора`
2) Ключ-значение 
	- Используют, когда важно значение модификатора. `menu-theme_pikes`
	- Структура полного имени модификатора соответствует
	`имя-блока_имя-модификатора_значение-модификатора`, 
	`имя-блока__имя-элемента_имя-модификатора_значение-модификатора`

#### Принципы работы с модификаторами 

**Модификатор нельзя использовать самостоятельно.**
С точки зрения БЭМ-методологии модификатор не может использоваться в отрыве от модифицируемого блока или элемента. Модификатор должен изменять вид, поведение или состояние сущности, а не заменять ее.

### БЭМ-сущность

БЭМ-сущностями называются блоки, элементы и модификаторы.

Это понятие может применяться как частное, если рассматривается отдельная БЭМ-сущность, и как собирательное для блоков, элементов и модификаторов. 

### Микс

Способ использования разных БЭМ-сущностей на одном DOM-узле.

Миксы позволяют:

- совмещать поведение и стили нескольких БЭМ-сущностей без дублирования кода;
- создавать семантически новые компоненты интерфейса на основе имеющихся БЭМ-сущностей.
Рассмотрим пример микса блока и элемента другого блока.

Допустим, в проекте ссылки реализованы блоком `link`. Необходимо сделать ссылками пункты меню. Существует несколько способов:

- Создать модификатор для пункта меню, который превратит пункт в ссылку. Но в таком случае для реализации модификатора придется скопировать поведение и стили блока `link`. Это приведет к дублированию кода.
    
- Воспользоваться миксом универсального блока `link` и элемента `link` блока `menu`. Микс двух БЭМ-сущностей позволит применить базовую функциональность ссылок из блока `link` и дополнительные CSS-правила из блока `menu` без копирования кода.
    

### БЭМ-дерево

Представление структуры веб-страницы в терминах блоков, элементов и модификаторов. Это абстракция над DOM-деревом, которая описывает имена БЭМ-сущностей, их состояния, порядок, вложенность и вспомогательные данные.

В реальных проектах БЭМ-дерево можно выразить любым форматом, который поддерживает древовидную структуру.

Рассмотрим пример DOM-дерева:

```
<header class="header">
    <img class="logo">
    <form class="search-form">
        <input class="input">
        <button class="button"></button>
    </form>
    <ul class="lang-switcher">
        <li class="lang-switcher__item">
            <a class="lang-switcher__link" href="url">en</a>
        </li>
        <li class="lang-switcher__item">
            <a class="lang-switcher__link" href="url">ru</a>
        </li>
    </ul>
</header>
```
Ему соответствует такое БЭМ-дерево:
```
header
    logo
    search-form
        input
        button
    lang-switcher
        lang-switcher__item
            lang-switcher__link
        lang-switcher__item
            lang-switcher__link
```

### Реализация блока

Набор различных технологий, определяющих следующие особенности БЭМ-сущности:

- поведение;
- внешний вид;
- тесты;
- шаблоны;
- документацию;
- описание зависимостей;
- дополнительные данные (например, картинки).

## Почитать про паттерны функционального программирования + посмотреть примеры использования

Функциональное программирование — одна из парадигм, которые помогают спроектировать программу так, чтобы она верно отражала эти правила и была устойчивой к изменениям.

### Композиция 

Сопоставление разных частей системы вместе называется _композицией_, а эти части — _элементами композиции_ (composition units).

**Композиция** — одна из важнейших проблем в программировании. Грамотное сопоставление частей делает программу расширяемой и отказоустойчивой.

Добиться хорошей композиции трудно, потому что для этого нужно правильно провести границы между элементами. Правильные границы — очень размытое понятие, но в целом можно выделить несколько свойств и требований:

- Границы должны быть проведены так, чтобы элемент решал только одну проблему, а не несколько (принцип разделения ответственности).
- Элементы ничего не должны знать об устройстве других элементов, а общаться они должны через данные (закон Деметры).
- Данные и настройки должны быть отделены от кода программы (The Twelve-Factor App).

В функциональном программировании элемент композиции — это функция. Передача данных через несколько вызовов функций — их композиция. Например, если мы хотим к числу 10 прибавить 5, а потом умножить результат на 42, то последовательно вызовем функции `add` и `multiply`:

```
function add(a, b) { 
	return a + b 
	} 
function multiply(a, b) { 
	return a * b 
	} 
	
const result = multiply(add(10, 5), 42)
```
Если разбить процесс на несколько шагов, то сперва мы получим результат сложения, а затем передадим его как аргумент умножения.

Такая последовательная передача данных на вход следующей функции и есть простейшая функциональная композиция.

### Чистые функции и побочные эффекты

Чтобы композиция функций была проще и не вызывала проблем, эти функции должны быть чистыми (pure). _Чистая функция_ — это функция, которая не вызывает побочных эффектов (side effects), то есть никак не влияет на состояние внешнего мира.

**Чистые функции всегда при вводе одинаковых аргументов выдают одинаковый результат. По этому свойству легко отличить чистую функцию от нечистой.**

```
function pureFn(a, b){
	return a+b;
}
```

А `impureFn()` нечистая — она будет возвращать разные значения, потому что использует случайное число:

```
function impureFn(a, b) {
  return ((a + b) * a) / Math.random()
}
```

И `alsoImpureFn()` тоже нечистая:

```
function alsoImpureFn() {
  return Date.now()
}
```

В последних двух случаях функции производят побочные эффекты, потому что обращаются к глобальным объектам `Math` и `Date`. Любое взаимодействие с чем-либо «снаружи» функции считается побочным эффектом, даже получение значений.

### Рекурсия

Так как в функциональном программировании нельзя менять состояние, то для итеративных процессов мы не можем применять циклы. Вместо этого нам нужно использовать отображение ([`map()`](https://doka.guide/js/array-map/)) и свёртку ([`reduce()`](https://doka.guide/js/array-reduce/)) или [рекурсию](https://doka.guide/js/recursion/).

Под рекурсией чаще всего понимает функцию, которая вызывает саму себя с базовым случаем. Базовый случай - это условие при выполнение которого рекурсия заканчивается и функция больше не вызывает саму себя.

```
// Пример рекурсивного вычиления факториала
function factorial(n) {
  if (n <= 1) {
    return 1
  }
  return n * factorial(n - 1)
}
```

### Функции высшего порядка 

Функции высшего порядка — это функции, которые работают с другими функциями, либо принимая их в виде параметров, либо возвращая их. Проще говоря, функцией высшего порядка называется такая функция, которая принимает функцию как аргумент или возвращает функцию в виде выходного значения.  
  
Например, встроенные функции JavaScript `Array.prototype.map`, `Array.prototype.filter` и `Array.prototype.reduce` являются функциями высшего порядка.

```
const isNegative = (n) => n < 0 
const isEven = (n) => n % 2 === 0 
const negative = list.filter(isNegative) 
const even = list.filter(isEven)
```


## Каррирование

В функциональном программирование — это преобразование функции с множеством аргументов `f(a,b,c)`  в набор вложенных функций с одним аргументом `f(a)(b)(c)`.

```
// Пример каррирования
function curry(func) {
  return function curried(...args) {
    if (args.length >= func.length) {
      return func.apply(this, args)
    }

    return function continueCurrying(...args2) {
      return curried.apply(this, args.concat(args2))
    }
  }
}
```

В примере выше мы проверяем, закончились ли аргументы. Если закончились, то передаём их все в оригинальную функцию и вызываем её. Если аргументы ещё есть, то используем рекурсию, чтобы каррировать ещё раз.


## Способы позиционирования контента на странице

Позиционирование - это возможность влиять на место отображения элемента на странице.

Свойство `position` задаёт способ позиционирования элемента в документе. Совместно со свойствами `left`, `right`, `top`, `bottom` или `inset` элементу задаётся его местоположение на странице.

**Поток документа** - порядок вывода элементов на страницу. В обычном виде все блоки выводятся в том порядке, в котором они записаны внутри HTML-документа.

Даже если к странице не подключено никаких стилей, к каждому элементу всё равно будут применяться CSS-правила, «зашитые» в движке браузера.

Правила расположения строчных и блочных элементов в нормальном потоке называются **контекстом форматирования**. Блочные элементы участвуют в формировании **блочного** контекста форматирования. Строчные элементы формируют **строчный** контекст форматирования. Расположение элементов в контексте форматирования зависит от направления письма для конкретного языка.

**Блочные элементы** в нормальном потоке располагаются друг под другом, всегда занимая всю доступную ширину родителя. Высота блочного элемента по умолчанию равна высоте его содержимого.

**Строчные элементы** располагаются друг за другом, как слова в предложении.
**Ширина и высота** строчного элемента равна ширине и высоте содержимого. В отличие от блочного элемента, мы не можем управлять шириной и высотой строчного элемента через CSS. Несколько строчных элементов будут стремиться уместиться на одной строке, насколько хватает ширины родителя. Если ширины родителя не хватает, то лишний текст строчного элемента переносится на следующую строку.

Поменять стандартное поведение можно при помощи CSS-свойства `display`.

Существует несколько видов позиционирования элементов на странице.

### Статическое позиционирование

Статическое позиционирование - это значение по умолчанию. Любой элемент, добавленный на страницу, будет иметь это значение и будет расположен в нормальном потоке документа согласно контексту форматирования родительского элемента. Свойства `left`, `right`, `top`, `bottom` и `z-index` игнорируются.

```
.positioned {
	position: static;
}
``` 

Элемент со значением `position: static` **не является** позиционированным элементом. Это важный момент, потому что элементы с любым другим значением свойства `position` создают внутри себя контекст наложения и становятся **опорными**. _Опорным элементом_ будем называть такой, относительно которого позиционируются дочерние элементы.

### Относительное позиционирование 

Элемент позиционируется так же, как и статичный, но его отображение может быть смещено относительно своего начального положения при помощи свойств `left`, `right`, `top`, `bottom` или `inset`. Это смещение **чисто визуальное** и не затрагивает положение соседних элементов, кроме случая, когда элемент выходит за границы родителя, имеющего возможность прокрутки.

На странице элемент будет занимать столько же места, как если бы он имел статичное позиционирование.

```
.positioned {
	position: relative;
}
```

### Абсолютное позиционирование 

Способ позиционирования, кажущийся наиболее понятным. Мы просто задаём абсолютное позиционирование и при помощи свойств `left`, `right`, `top`, `bottom` или `inset` регулируем положение элемента. Есть ряд особенностей такого позиционирования:

- Элемент убирается из основного потока документа. То есть перестаёт влиять на положение окружающих элементов и на размер родителя. Можно представить себе, что элемент уходит на слой выше и перестаёт взаимодействовать со всеми элементами, кроме своих потомков.
- Элемент позиционируется относительно ближайшего позиционированного предка. То есть браузер идёт вверх по дереву элементов и ищет ближайшего _опорного_ родителя. И затем располагает наш элемент относительно этого родителя.
- Если элемент был частью строчного контекста форматирования, он приобретает блочный контекст форматирования. К нему становится применима блочная модель.
- Если элемент был блочным и занимал всю ширину своего родителя, то теперь его ширина будет определяться шириной контента.
- Отступы элемента с `position: absolute` не схлопываются с отступами соседних элементов.

```
.positioned {
	position: absolute;
}
```


### Фиксированное позиционирование 

Иногда требуется позиционировать элемент не относительно родителя, а относительно окна браузера вне зависимости от вложенности. Для решения подобной задачи подходит `position: fixed`. Свойство так же, как и предыдущее, работает с указанием смещения `left`, `right`, `top`, `bottom` или `inset`. У такого способа позиционирования есть ряд особенностей:

- Элемент убирается из основного потока документа. То есть перестаёт влиять на положение окружающих элементов и на размер родителя. Можно представить себе, что элемент уходит на слой выше и перестаёт взаимодействовать со всеми элементами, кроме своих потомков.
- Элемент позиционируется относительно окна браузера, за исключением случаев, если один из родителей имеет значения свойств `transform`, `perspective` или `filter`, отличные от `none`. В этом случае блок становится _опорным_, и позиционирование будет производиться уже относительно него, а не окна браузера.

```
.positioned {
	position: fixed;
}
```

### Гибридное позиционирование (Sticky)

Элемент позиционируется в нормальном потоке так же, как и статичный, а затем смещается при помощи свойств `left`, `right`, `top`, `bottom` или `inset` относительно ближайшего родителя, имеющего прокрутку. Это свойство применяется, когда нам нужно зафиксировать какой-либо элемент не сразу, а при прокрутке родителя до какого-то известного положения.

У такого позиционирования есть ряд особенностей:

- Элемент ведёт себя как элемент с относительным (`relative`) позиционированием до тех пор, пока его родитель не будет прокручен до определённой границы. Как правило, эта точка совпадает с положением верхней границы нашего элемента, но может быть изменена с использованием свойства `top`.
- Элемент остаётся «приклеенным» во время прокрутки родителя до тех пор, пока не «встретит» противоположную границу своего родителя.

```
.positioned {
	position: sticky;
}
```

### Z-index 

Свойство `z-index` позволяет управлять порядком наложения элементов друг на друга.

Значением свойства `z-index` может быть отрицательное или положительное целое число. Значение по умолчанию — `auto`.

Браузер выстраивает блоки страницы не только по вертикали и горизонтали, но и по глубине. Это встроенный механизм обработки документа. Чем ниже блок в разметке, тем выше он в _стопке._ Управлять порядком наложения блоков мы как раз и можем при помощи `z-index`.

- `z-index` срабатывает для элементов с позиционированием отличающимся от статичного (значения `relative`, `absolute`, `fixed`, `sticky`.
- Исключение из правил: `z-index` работает с элементами, у которых значение свойства `opacity`меньше 1. Например, трюк с `opacity: 0.999` почти не повлияет на внешний вид, но позволит использовать `z-index` без изменения позиционирования элемента.
- `z-index` также срабатывает у флекс- и грид-элементов и везде, где создаётся контекст наложения.
- Если `z-index` не указан, то блоки накладываются друг на друга в том порядке, в котором указаны в разметке. Чем ниже в разметке, тем выше в _стопке_. А если указан, то стопка блоков формируется согласно значению этого свойства.

## Веса селекторов

Специфичность — это алгоритм, благодаря которому браузер определяет, какие именно стили из всего набора применить к элементу. В вычислениях участвуют CSS-селекторы. Если одному и тому же элементу подходит сразу несколько CSS-правил с разными селекторами, то браузер применяет те стили, вес селектора которых больше. Правило каскада «кто ниже, тот и выигрывает» при этом может нарушаться.

Вес селектора — это условные четыре позиции `x, x, x, x`, которые заполняются нулями и единицами в соответствии с содержимым селектора. 

Типы селекторов по убыванию специфичности: 

1. **Инлайн стили**: 1,0,0,0
2. **Селекторы по идентификатору (ID)**: 0,1,0,0
3. **Селекторы по классу, селекторы по атрибуту и селекторы с псевдоклассами**: 0,0,1,0
4. **Селекторы по тегу, селекторы с псевдоэлементами**: 0,0,0,1

Комбинаторы `+`, `>`, `~`, универсальный селектор `*` и псевдокласс `:where()` веса не имеют.

Псевдоклассы `:is()`, `:has()` и `:not()` принимают вес наиболее специфичного селектора внутри скобок.

CSS-свойства, написанные в атрибуте `style` внутри HTML-разметки, перебивают свойства, написанные для этого элемента во внешних CSS-файлах или внутри тега `<style>`. Так что формально атрибут `style` самый специфичный, у него самый большой вес.

```
Пример с инлайн стилями

<div style="color: purple; border: none">ЧТо-то</div>

// В данном случае вес селектора будет 1.0.0.0

```

```
Пример с селектором по идентификатору 

#myID {
	color: blue;
}

// В данном случае вес селектора будет 0.1.0.0
```

```
Пример с селектором по классу 

.menu {
	color: red;
}

// В данном случае вес селектора будет 0.0.1.0
```

```
Пример с селектором по атрибуту 

[attr] {
	color: red;
}

// В данном случае вес селектора будет 0.0.1.0
```

```
Пример с селектором по элементу 

div {
	color: grey;
}

// В данном случае вес селектора будет 0.0.0.1
```

```
Пример с селектором по псевдоэлементу

menu::before {
	color: green;
}

// В данном случае вес селектора будет 0.0.0.1
```

### Комбинированные селекторы

`div#some` состоит из одного селектора по тегу и одного идентификатора. Селектор по тегу увеличивает последнюю цифру, селектор по идентификатору — первую. Вес селектора равен 0.1.0.1.

`section h1` состоит из двух селекторов по тегу. Увеличиваем последнюю цифру на два и получаем вес ) 0.0.0.2.

`#block section > .list a` состоит из идентификатора (первая цифра), двух тегов (последняя цифра) и класса (вторая цифра). Вес селектора равен 0.1.1.2.

`* .list a` состоит из одного класса и одного тега. Итоговый вес будет 0.0.1.1. Универсальный селектор ничего не весит

### !important

Ключевое слово `!important` нарушает все установленные спецификацией законы и насильно применяет свойство. Если к свойству применен `!important`, то это свойство будет иметь наивысший приоритет, даже выше, чем inline стили.

