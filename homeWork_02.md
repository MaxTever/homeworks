### Занятие 3 - Объекты и функции  

### **Код с примерами находиться в файле homeWork_02.js**
### Задание 1 - Создать объект counter всеми возможными способами; 

**Способы:**  
1. Создание объекта с помощью литерала объекта `counter = {}`;
2. Создание объекта c помощью `new Object()` (используя конструктор объекта);
3. Создание с помощью `Object.create(prototype, properties)`
	- Можно указать первым аргументом null, чтобы создать объект без прототипа
	- Во втором аргументе можно указать необходимые свойства объекта с дескрипторами свойств
4.  Создание объекта с помощью `Object.assign(target, source)`, хотя это скорее является копированием объекта;
5. Создание объекта с помощью функции конструктора `function Counter(){}`,  данные функции должны вызывать с оператором `new` ; 
6. Создание объекта с помощью класса `class Counter{}`;

### Задание 2 - Скопировать объект counter всеми возможными способами;

Существует два вида копирования объектов поверхностное и глубокое.
#### Поверхностное копирование
При поверхностном копировании создается новый объект или массив, и его свойства или элементы копируются из оригинала. Однако если свойства объекта или элементы массива сами являются объектами или массивами, они копируются по ссылке, а не по значению.
#### Глубокое копирование
Глубокое копирование создает полностью независимую копию объекта или массива, включая все вложенные объекты и массивы. Таким образом, изменения в копии не влияют на оригинал и наоборот.

**Способы для поверхностного копирования:** 
1.  `Object.assign(target, source)`;
2.  Spread operator `const clonedCounter = {...counter}`;
3.  Копирование объекта с наследованием прототипа `Object.create(prototype, properties)`
4. Написание своей функции для поверхностного копирования `function shallowCopy(obj){}`

**Способы для глубокого копирования объектов:** 
1.  Функции из сторонних библиотек(например `cloneDeep` из lodash);
2.  Сериализация объекта с помощью `JSON.parse(JSON.stringify(obj))`, однако при использовании данного способа необходимо помнить про нюансы: 
	- У этого метода есть ограничение — копируемые данные должны быть сериализуемы.
	- Несериализуемые: примитив undefined, функция, symbol - при вызове `JSON.stringify` получаем `undefined`
	- Если в массиве или объекте в качестве ключа или значения будут несериализуемые данные: 
		- для массивов: такие значения будут превращены в `null`, 
		- для объектов: такие значения будут опущены, а если symbol является ключом объекта, то он будет проигнорирован, даже при использовании функции replace
3.  `structuredClone()` про особенности данного метода будет далее;
4. Написание своей функции для глубокого копирования объекта `function deepCopy(){}`


### Задание 3 - Создать функцию makeCounter всеми описанными и возможными способами;

1. Функция конструктор makeCounter; 
2. Функция с использованием замыкания; 
3. Использование класса (ведь это разновидность функций)
4. В теории можно использовать Proxy, С помощью proxy-объекта можно управлять доступом к свойствам.
### Задание 4 - Прочитать и описать работу глобальной функции structuredClone();


Данная глобальная функция используется для глубокого копирования объектов. Эта функция выполняет глубокое копирование, включая все вложенные свойства, и сохраняет оригинальную структуру данных. Использует *The structured clone algorithm*(Алгоритм структурированного клонирования). 
Алгоритм, по существу, перебирает все поля оригинального объекта, дублируя значения каждого поля в новый объект. Если поле представляет из себя объект с собственными полями, то эти дочерние поля также перебираются рекурсивно, пока каждое поле и все дочерние поля не будут продублированы в новый объект.

**Синтаксис:** 

```
const deepCopy = structuredClone(val);
```

**val** - в данном случае может быть любым объектом или примитивом который нужно скопировать.

**deepCopy** - независимая копия переданного объекта. Изменение копии не будет влиять на оригинальный объект.

**Позволяет:** 
- Клонировать бесконечно вложенные объекты и массивы.
- Клонировать циклические ссылки.
- Клонировать широкий спектр типов JavaScript, таких как: `Date`_,_ `Set`_,_ `Map`_,_ `Error`_,_ `RegExp`_,_ `ArrayBuffer`_,_ `Blob`_,_ `File`_,_ `ImageData` 
- Передавать любые передаваемые объекты (*Transferable objects*)

**Важные особенности и ограничения:** 
- Если использовать structuredClone() с экземпляром класса, то прототип объекта не будет скопирован, это означает что скопированный объект будет иметь обычный прототип Object.
- Методы объекта не копируются и при этом будет выброшена ошибка DataCloneError.
- Не могут быть скопированы объекты ссылающиеся на DOM 
- Сеттеры и геттеры тоже не могут быть скопированы

### Задание 5 - Написать функцию глубокого сравнения двух объектов;

```
function deepEqual(obj1, obj2) {
    //Проверка ссылки
    if (obj1 === obj2) {return true}
    //Проверка типа
    if (typeof obj1 !== 'object'|| obj1 === null || typeof obj2 !== 'object' || obj2 === null) {
        return false;
    }
    //Можно добавить дополнительные проверки на специальные типы объектов
    let keys1 = Object.keys(obj1);
    let keys2 = Object.keys(obj2);
    // Проверка количества свойств
    if (keys1.length !== keys2.length) {return false}
    for (let key of keys1) {
        if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {
            return false;
        }
    }
    return true;

}
```

### Задание 6 - Развернуть строку в обратном направлении при помощи методов массивов;

```
function reverseStr(str){

    return str.split('').reverse().join('');

}
```
